<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>树: Tree::binaryTree&lt; T, Comparator &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">树
   &#160;<span id="projectnumber">0.1</span>
   </div>
   <div id="projectbrief">数据结构_第6章</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('a05401.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-static-methods">Static Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#pri-static-attribs">Static Private Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="a05398.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Tree::binaryTree&lt; T, Comparator &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>用二叉链表实现的二叉树类  
 <a href="a05401.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="a04520_source.html">binaryTree.hh</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for Tree::binaryTree&lt; T, Comparator &gt;:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="a05399.svg" width="100%" height="600"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div></div>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05405.html">BinNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">二叉链表的结点类  <a href="a05405.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:afaa28be8afcfed930217d6d75ae18383"><td class="memItemLeft" align="right" valign="top">typedef T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05401.html#afaa28be8afcfed930217d6d75ae18383">value_type</a></td></tr>
<tr class="memdesc:afaa28be8afcfed930217d6d75ae18383"><td class="mdescLeft">&#160;</td><td class="mdescRight">类型别名定义  <a href="a05401.html#afaa28be8afcfed930217d6d75ae18383">More...</a><br /></td></tr>
<tr class="separator:afaa28be8afcfed930217d6d75ae18383"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a165837c10ea2f371ac7989e35acb11b5"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="a05401.html#afaa28be8afcfed930217d6d75ae18383">value_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05401.html#a165837c10ea2f371ac7989e35acb11b5">reference</a></td></tr>
<tr class="memdesc:a165837c10ea2f371ac7989e35acb11b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">数据的引用  <a href="a05401.html#a165837c10ea2f371ac7989e35acb11b5">More...</a><br /></td></tr>
<tr class="separator:a165837c10ea2f371ac7989e35acb11b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af83b64f3ad17abdaab0c208a4c0afafc"><td class="memItemLeft" align="right" valign="top">typedef size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05401.html#af83b64f3ad17abdaab0c208a4c0afafc">size_type</a></td></tr>
<tr class="memdesc:af83b64f3ad17abdaab0c208a4c0afafc"><td class="mdescLeft">&#160;</td><td class="mdescRight">计数器类型  <a href="a05401.html#af83b64f3ad17abdaab0c208a4c0afafc">More...</a><br /></td></tr>
<tr class="separator:af83b64f3ad17abdaab0c208a4c0afafc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a57bd7d354167f52331f751bf0dab4dc7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05401.html#a57bd7d354167f52331f751bf0dab4dc7">binaryTree</a> ()</td></tr>
<tr class="memdesc:a57bd7d354167f52331f751bf0dab4dc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new binary <a class="el" href="a05445.html">Tree</a> object.  <a href="a05401.html#a57bd7d354167f52331f751bf0dab4dc7">More...</a><br /></td></tr>
<tr class="separator:a57bd7d354167f52331f751bf0dab4dc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3adeeaa5aed3b3d4852c906ff829cab5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05401.html#a3adeeaa5aed3b3d4852c906ff829cab5">binaryTree</a> (const <a class="el" href="a05401.html#afaa28be8afcfed930217d6d75ae18383">value_type</a> &amp;x)</td></tr>
<tr class="memdesc:a3adeeaa5aed3b3d4852c906ff829cab5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new binary <a class="el" href="a05445.html">Tree</a> object.  <a href="a05401.html#a3adeeaa5aed3b3d4852c906ff829cab5">More...</a><br /></td></tr>
<tr class="separator:a3adeeaa5aed3b3d4852c906ff829cab5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30b25e4df45a1148e513f7200da3b1b9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05401.html#a30b25e4df45a1148e513f7200da3b1b9">binaryTree</a> (const <a class="el" href="a05401.html">binaryTree</a> &amp;rhs)</td></tr>
<tr class="memdesc:a30b25e4df45a1148e513f7200da3b1b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new binary <a class="el" href="a05445.html">Tree</a> object 拷贝构造函数  <a href="a05401.html#a30b25e4df45a1148e513f7200da3b1b9">More...</a><br /></td></tr>
<tr class="separator:a30b25e4df45a1148e513f7200da3b1b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09214bfe65861c9ff6ea1534429d03cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a05401.html">binaryTree</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05401.html#a09214bfe65861c9ff6ea1534429d03cb">operator=</a> (const <a class="el" href="a05401.html">binaryTree</a> &amp;rhs)</td></tr>
<tr class="memdesc:a09214bfe65861c9ff6ea1534429d03cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">赋值运算符重载  <a href="a05401.html#a09214bfe65861c9ff6ea1534429d03cb">More...</a><br /></td></tr>
<tr class="separator:a09214bfe65861c9ff6ea1534429d03cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b41680a8246aa1c947cad46b984e01e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05401.html#a3b41680a8246aa1c947cad46b984e01e">binaryTree</a> (<a class="el" href="a05401.html">binaryTree</a> &amp;&amp;rhs)</td></tr>
<tr class="memdesc:a3b41680a8246aa1c947cad46b984e01e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new binary <a class="el" href="a05445.html">Tree</a> object 移动构造函数  <a href="a05401.html#a3b41680a8246aa1c947cad46b984e01e">More...</a><br /></td></tr>
<tr class="separator:a3b41680a8246aa1c947cad46b984e01e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3d64f5301306cc864a5138ae1761952"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a05401.html">binaryTree</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05401.html#aa3d64f5301306cc864a5138ae1761952">operator=</a> (<a class="el" href="a05401.html">binaryTree</a> &amp;&amp;rhs)</td></tr>
<tr class="memdesc:aa3d64f5301306cc864a5138ae1761952"><td class="mdescLeft">&#160;</td><td class="mdescRight">移动赋值运算符  <a href="a05401.html#aa3d64f5301306cc864a5138ae1761952">More...</a><br /></td></tr>
<tr class="separator:aa3d64f5301306cc864a5138ae1761952"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98c1d78d85e836d3424ad66cc2425ee2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05401.html#a98c1d78d85e836d3424ad66cc2425ee2">~binaryTree</a> ()</td></tr>
<tr class="memdesc:a98c1d78d85e836d3424ad66cc2425ee2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy the binary <a class="el" href="a05445.html">Tree</a> object.  <a href="a05401.html#a98c1d78d85e836d3424ad66cc2425ee2">More...</a><br /></td></tr>
<tr class="separator:a98c1d78d85e836d3424ad66cc2425ee2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9194d1f92b108620b53180da999aaa48"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05401.html#a9194d1f92b108620b53180da999aaa48">clear</a> ()</td></tr>
<tr class="memdesc:a9194d1f92b108620b53180da999aaa48"><td class="mdescLeft">&#160;</td><td class="mdescRight">清空二叉树 函数返回后，对象的成员root_将被置nullptr  <a href="a05401.html#a9194d1f92b108620b53180da999aaa48">More...</a><br /></td></tr>
<tr class="separator:a9194d1f92b108620b53180da999aaa48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3496f157e966e3acc0bfc97d0b9854b0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05401.html#a3496f157e966e3acc0bfc97d0b9854b0">empty</a> () const</td></tr>
<tr class="memdesc:a3496f157e966e3acc0bfc97d0b9854b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">判断二叉树是否为空树  <a href="a05401.html#a3496f157e966e3acc0bfc97d0b9854b0">More...</a><br /></td></tr>
<tr class="separator:a3496f157e966e3acc0bfc97d0b9854b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6904ca2a5311bc475d24cd7859dff66b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a05401.html#afaa28be8afcfed930217d6d75ae18383">value_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05401.html#a6904ca2a5311bc475d24cd7859dff66b">root</a> (const <a class="el" href="a05401.html#afaa28be8afcfed930217d6d75ae18383">value_type</a> &amp;flag) const</td></tr>
<tr class="memdesc:a6904ca2a5311bc475d24cd7859dff66b"><td class="mdescLeft">&#160;</td><td class="mdescRight">返回根结点的数据  <a href="a05401.html#a6904ca2a5311bc475d24cd7859dff66b">More...</a><br /></td></tr>
<tr class="separator:a6904ca2a5311bc475d24cd7859dff66b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a40ebe3b6ce6854040202e4fb5c0f05"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a05401.html#afaa28be8afcfed930217d6d75ae18383">value_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05401.html#a1a40ebe3b6ce6854040202e4fb5c0f05">lchild</a> (const <a class="el" href="a05401.html#afaa28be8afcfed930217d6d75ae18383">value_type</a> &amp;x, const <a class="el" href="a05401.html#afaa28be8afcfed930217d6d75ae18383">value_type</a> &amp;flag) const</td></tr>
<tr class="memdesc:a1a40ebe3b6ce6854040202e4fb5c0f05"><td class="mdescLeft">&#160;</td><td class="mdescRight">获得数据为x的结点的左child  <a href="a05401.html#a1a40ebe3b6ce6854040202e4fb5c0f05">More...</a><br /></td></tr>
<tr class="separator:a1a40ebe3b6ce6854040202e4fb5c0f05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0bcb9734e8955c6b1e982d584320f64"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a05401.html#afaa28be8afcfed930217d6d75ae18383">value_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05401.html#ab0bcb9734e8955c6b1e982d584320f64">rchild</a> (const <a class="el" href="a05401.html#afaa28be8afcfed930217d6d75ae18383">value_type</a> &amp;x, const <a class="el" href="a05401.html#afaa28be8afcfed930217d6d75ae18383">value_type</a> &amp;flag) const</td></tr>
<tr class="memdesc:ab0bcb9734e8955c6b1e982d584320f64"><td class="mdescLeft">&#160;</td><td class="mdescRight">获得数据为x的结点的右child  <a href="a05401.html#ab0bcb9734e8955c6b1e982d584320f64">More...</a><br /></td></tr>
<tr class="separator:ab0bcb9734e8955c6b1e982d584320f64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadacd70978bd8a75adc9ef2c4f6f40e4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05401.html#aadacd70978bd8a75adc9ef2c4f6f40e4">delLeft</a> (const <a class="el" href="a05401.html#afaa28be8afcfed930217d6d75ae18383">value_type</a> &amp;x)</td></tr>
<tr class="memdesc:aadacd70978bd8a75adc9ef2c4f6f40e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">删除左subtree  <a href="a05401.html#aadacd70978bd8a75adc9ef2c4f6f40e4">More...</a><br /></td></tr>
<tr class="separator:aadacd70978bd8a75adc9ef2c4f6f40e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad960b8028f5d1d8c9282160aede6f68b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05401.html#ad960b8028f5d1d8c9282160aede6f68b">delRight</a> (const <a class="el" href="a05401.html#afaa28be8afcfed930217d6d75ae18383">value_type</a> &amp;x)</td></tr>
<tr class="memdesc:ad960b8028f5d1d8c9282160aede6f68b"><td class="mdescLeft">&#160;</td><td class="mdescRight">删除右subtree  <a href="a05401.html#ad960b8028f5d1d8c9282160aede6f68b">More...</a><br /></td></tr>
<tr class="separator:ad960b8028f5d1d8c9282160aede6f68b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0a3d9e4bc6035a9c914e5109d6688b7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05401.html#aa0a3d9e4bc6035a9c914e5109d6688b7">preOrder</a> (std::ostream &amp;out=std::cout) const</td></tr>
<tr class="memdesc:aa0a3d9e4bc6035a9c914e5109d6688b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">前序遍历(递归版本)  <a href="a05401.html#aa0a3d9e4bc6035a9c914e5109d6688b7">More...</a><br /></td></tr>
<tr class="separator:aa0a3d9e4bc6035a9c914e5109d6688b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9d71e1c10511c865aed5c553ac24b72"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05401.html#af9d71e1c10511c865aed5c553ac24b72">preOrder_loop</a> (std::ostream &amp;out=std::cout) const</td></tr>
<tr class="memdesc:af9d71e1c10511c865aed5c553ac24b72"><td class="mdescLeft">&#160;</td><td class="mdescRight">前序遍历(非递归版本)  <a href="a05401.html#af9d71e1c10511c865aed5c553ac24b72">More...</a><br /></td></tr>
<tr class="separator:af9d71e1c10511c865aed5c553ac24b72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6003da876c500af081001c549a90433"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05401.html#ac6003da876c500af081001c549a90433">inOrder</a> (std::ostream &amp;out=std::cout) const</td></tr>
<tr class="memdesc:ac6003da876c500af081001c549a90433"><td class="mdescLeft">&#160;</td><td class="mdescRight">中序遍历(递归版本)  <a href="a05401.html#ac6003da876c500af081001c549a90433">More...</a><br /></td></tr>
<tr class="separator:ac6003da876c500af081001c549a90433"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cb786410ed6c0f61969a09b76f4da0c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05401.html#a6cb786410ed6c0f61969a09b76f4da0c">inOrder_loop</a> (std::ostream &amp;out=std::cout) const</td></tr>
<tr class="memdesc:a6cb786410ed6c0f61969a09b76f4da0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">中序遍历(非递归版本)  <a href="a05401.html#a6cb786410ed6c0f61969a09b76f4da0c">More...</a><br /></td></tr>
<tr class="separator:a6cb786410ed6c0f61969a09b76f4da0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29e131a4f32bf7ac33dad9cd60d5ca7b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05401.html#a29e131a4f32bf7ac33dad9cd60d5ca7b">postOrder</a> (std::ostream &amp;out=std::cout) const</td></tr>
<tr class="memdesc:a29e131a4f32bf7ac33dad9cd60d5ca7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">后序遍历(递归版本)  <a href="a05401.html#a29e131a4f32bf7ac33dad9cd60d5ca7b">More...</a><br /></td></tr>
<tr class="separator:a29e131a4f32bf7ac33dad9cd60d5ca7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24d90fc12dae5213ddb8b21baf14cc66"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05401.html#a24d90fc12dae5213ddb8b21baf14cc66">postOrder_loop</a> (std::ostream &amp;out=std::cout) const</td></tr>
<tr class="memdesc:a24d90fc12dae5213ddb8b21baf14cc66"><td class="mdescLeft">&#160;</td><td class="mdescRight">后序遍历(非递归版本)  <a href="a05401.html#a24d90fc12dae5213ddb8b21baf14cc66">More...</a><br /></td></tr>
<tr class="separator:a24d90fc12dae5213ddb8b21baf14cc66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94dcc51623e366cb26fa5e543b19c6f8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05401.html#a94dcc51623e366cb26fa5e543b19c6f8">levelOrder</a> (std::ostream &amp;out=std::cout) const</td></tr>
<tr class="memdesc:a94dcc51623e366cb26fa5e543b19c6f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">层次遍历  <a href="a05401.html#a94dcc51623e366cb26fa5e543b19c6f8">More...</a><br /></td></tr>
<tr class="separator:a94dcc51623e366cb26fa5e543b19c6f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40668a92e598befe619d6e1ffe5f2a52"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05401.html#a40668a92e598befe619d6e1ffe5f2a52">createTree</a> (const <a class="el" href="a05401.html#afaa28be8afcfed930217d6d75ae18383">value_type</a> &amp;flag=<a class="el" href="a05401.html#afaa28be8afcfed930217d6d75ae18383">value_type</a>{}, std::istream &amp;in=std::cin)</td></tr>
<tr class="memdesc:a40668a92e598befe619d6e1ffe5f2a52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="a05445.html">Tree</a> object.  <a href="a05401.html#a40668a92e598befe619d6e1ffe5f2a52">More...</a><br /></td></tr>
<tr class="separator:a40668a92e598befe619d6e1ffe5f2a52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04b72fb96511872389c079dcdd8dcd39"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a05401.html#afaa28be8afcfed930217d6d75ae18383">value_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05401.html#a04b72fb96511872389c079dcdd8dcd39">parent</a> (<a class="el" href="a05401.html#afaa28be8afcfed930217d6d75ae18383">value_type</a> x, const <a class="el" href="a05401.html#afaa28be8afcfed930217d6d75ae18383">value_type</a> &amp;flag) const</td></tr>
<tr class="memdesc:a04b72fb96511872389c079dcdd8dcd39"><td class="mdescLeft">&#160;</td><td class="mdescRight">返回数据为x的结点的parent结点  <a href="a05401.html#a04b72fb96511872389c079dcdd8dcd39">More...</a><br /></td></tr>
<tr class="separator:a04b72fb96511872389c079dcdd8dcd39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7389dcd912456fbc77ad350a1134732"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a05401.html#af83b64f3ad17abdaab0c208a4c0afafc">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05401.html#ac7389dcd912456fbc77ad350a1134732">height</a> () const</td></tr>
<tr class="memdesc:ac7389dcd912456fbc77ad350a1134732"><td class="mdescLeft">&#160;</td><td class="mdescRight">返回二叉树的高度(递归版本)  <a href="a05401.html#ac7389dcd912456fbc77ad350a1134732">More...</a><br /></td></tr>
<tr class="separator:ac7389dcd912456fbc77ad350a1134732"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18c50f432143bfe2feade7347f8ff770"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a05401.html#af83b64f3ad17abdaab0c208a4c0afafc">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05401.html#a18c50f432143bfe2feade7347f8ff770">height_loop</a> () const</td></tr>
<tr class="memdesc:a18c50f432143bfe2feade7347f8ff770"><td class="mdescLeft">&#160;</td><td class="mdescRight">返回二叉树的高度(非递归版本)  <a href="a05401.html#a18c50f432143bfe2feade7347f8ff770">More...</a><br /></td></tr>
<tr class="separator:a18c50f432143bfe2feade7347f8ff770"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2559965baee16c7a496049bccf703af"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a05401.html#af83b64f3ad17abdaab0c208a4c0afafc">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05401.html#af2559965baee16c7a496049bccf703af">size</a> () const</td></tr>
<tr class="memdesc:af2559965baee16c7a496049bccf703af"><td class="mdescLeft">&#160;</td><td class="mdescRight">返回二叉树的结点数(递归版本)  <a href="a05401.html#af2559965baee16c7a496049bccf703af">More...</a><br /></td></tr>
<tr class="separator:af2559965baee16c7a496049bccf703af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe73f325fd03d9281d0330b7a2d0c8a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a05401.html#af83b64f3ad17abdaab0c208a4c0afafc">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05401.html#afe73f325fd03d9281d0330b7a2d0c8a8">size_loop</a> () const</td></tr>
<tr class="memdesc:afe73f325fd03d9281d0330b7a2d0c8a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">返回二叉树的结点数(非递归版本)  <a href="a05401.html#afe73f325fd03d9281d0330b7a2d0c8a8">More...</a><br /></td></tr>
<tr class="separator:afe73f325fd03d9281d0330b7a2d0c8a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81357f9d197b142b8126579ce51fab17"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05401.html#a81357f9d197b142b8126579ce51fab17">swaplr</a> ()</td></tr>
<tr class="memdesc:a81357f9d197b142b8126579ce51fab17"><td class="mdescLeft">&#160;</td><td class="mdescRight">交换左右子树  <a href="a05401.html#a81357f9d197b142b8126579ce51fab17">More...</a><br /></td></tr>
<tr class="separator:a81357f9d197b142b8126579ce51fab17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1203fc03a4506fa073d80545ce1de6a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a05401.html#af83b64f3ad17abdaab0c208a4c0afafc">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05401.html#a1203fc03a4506fa073d80545ce1de6a3">CountDegreeTwo</a> () const</td></tr>
<tr class="memdesc:a1203fc03a4506fa073d80545ce1de6a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">统计树中度为2的结点的个数  <a href="a05401.html#a1203fc03a4506fa073d80545ce1de6a3">More...</a><br /></td></tr>
<tr class="separator:a1203fc03a4506fa073d80545ce1de6a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b05f46a36ae7f0f98dfa65dc908fdca"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05401.html#a2b05f46a36ae7f0f98dfa65dc908fdca">isCompleteTree</a> () const</td></tr>
<tr class="memdesc:a2b05f46a36ae7f0f98dfa65dc908fdca"><td class="mdescLeft">&#160;</td><td class="mdescRight">返回是否完全二叉树  <a href="a05401.html#a2b05f46a36ae7f0f98dfa65dc908fdca">More...</a><br /></td></tr>
<tr class="separator:a2b05f46a36ae7f0f98dfa65dc908fdca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afee39e46bd46f7178347eaae0581063b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05401.html#afee39e46bd46f7178347eaae0581063b">isFullBinaryTree</a> () const</td></tr>
<tr class="memdesc:afee39e46bd46f7178347eaae0581063b"><td class="mdescLeft">&#160;</td><td class="mdescRight">是否满二叉树  <a href="a05401.html#afee39e46bd46f7178347eaae0581063b">More...</a><br /></td></tr>
<tr class="separator:afee39e46bd46f7178347eaae0581063b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a31c21bc3323bcc69b5053c325aacf015"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05401.html#a31c21bc3323bcc69b5053c325aacf015">is_symmetrical_tree</a> (const <a class="el" href="a05401.html">binaryTree</a> &amp;lhs, const <a class="el" href="a05401.html">binaryTree</a> &amp;rhs)</td></tr>
<tr class="memdesc:a31c21bc3323bcc69b5053c325aacf015"><td class="mdescLeft">&#160;</td><td class="mdescRight">判断两棵二叉树是否互为镜像 两棵二叉树#1和#2互为镜像，如果二者皆为空树；或二者根结点的值相同，且#1的左、右子树与#2的右、左子树互为镜像  <a href="a05401.html#a31c21bc3323bcc69b5053c325aacf015">More...</a><br /></td></tr>
<tr class="separator:a31c21bc3323bcc69b5053c325aacf015"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:ad6b1eaee9b04cf92b17732ee573786c0"><td class="memItemLeft" align="right" valign="top">const typedef <a class="el" href="a05401.html#afaa28be8afcfed930217d6d75ae18383">value_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05401.html#ad6b1eaee9b04cf92b17732ee573786c0">const_reference</a></td></tr>
<tr class="memdesc:ad6b1eaee9b04cf92b17732ee573786c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">数据的常量引用  <a href="a05401.html#ad6b1eaee9b04cf92b17732ee573786c0">More...</a><br /></td></tr>
<tr class="separator:ad6b1eaee9b04cf92b17732ee573786c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a8c8d3f85b7ce46148d672e722c8a7c5a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a05405.html">BinNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05401.html#a8c8d3f85b7ce46148d672e722c8a7c5a">find</a> (const <a class="el" href="a05401.html#afaa28be8afcfed930217d6d75ae18383">value_type</a> &amp;x, <a class="el" href="a05405.html">BinNode</a> *<a class="el" href="a05401.html#a6904ca2a5311bc475d24cd7859dff66b">root</a>) const</td></tr>
<tr class="memdesc:a8c8d3f85b7ce46148d672e722c8a7c5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">在以root为根的树中(前序)查找数据为x的结点，返回指向该结点的指针  <a href="a05401.html#a8c8d3f85b7ce46148d672e722c8a7c5a">More...</a><br /></td></tr>
<tr class="separator:a8c8d3f85b7ce46148d672e722c8a7c5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d02ce7e04ec1724189dbfbaac976dad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05401.html#a9d02ce7e04ec1724189dbfbaac976dad">clear</a> (<a class="el" href="a05405.html">BinNode</a> *&amp;<a class="el" href="a05401.html#a6904ca2a5311bc475d24cd7859dff66b">root</a>)</td></tr>
<tr class="memdesc:a9d02ce7e04ec1724189dbfbaac976dad"><td class="mdescLeft">&#160;</td><td class="mdescRight">清空以root为根结点的树，包括清除根结点  <a href="a05401.html#a9d02ce7e04ec1724189dbfbaac976dad">More...</a><br /></td></tr>
<tr class="separator:a9d02ce7e04ec1724189dbfbaac976dad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42a46bd0bb2f1f4af08fb0bb97c553ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a05405.html">BinNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05401.html#a42a46bd0bb2f1f4af08fb0bb97c553ae">clone</a> (<a class="el" href="a05405.html">BinNode</a> *_root) const</td></tr>
<tr class="memdesc:a42a46bd0bb2f1f4af08fb0bb97c553ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal method to clone subtree.  <a href="a05401.html#a42a46bd0bb2f1f4af08fb0bb97c553ae">More...</a><br /></td></tr>
<tr class="separator:a42a46bd0bb2f1f4af08fb0bb97c553ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcd5d328b700cd21fe3b83a9389afbff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05401.html#afcd5d328b700cd21fe3b83a9389afbff">preOrder</a> (<a class="el" href="a05405.html">BinNode</a> *<a class="el" href="a05401.html#a6904ca2a5311bc475d24cd7859dff66b">root</a>, std::ostream &amp;out=std::cout) const</td></tr>
<tr class="memdesc:afcd5d328b700cd21fe3b83a9389afbff"><td class="mdescLeft">&#160;</td><td class="mdescRight">前序遍历以root为根结点的树(递归版本)  <a href="a05401.html#afcd5d328b700cd21fe3b83a9389afbff">More...</a><br /></td></tr>
<tr class="separator:afcd5d328b700cd21fe3b83a9389afbff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaccc2e0eabfaa2e0afbdb8d8f8167810"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05401.html#aaccc2e0eabfaa2e0afbdb8d8f8167810">inOrder</a> (<a class="el" href="a05405.html">BinNode</a> *<a class="el" href="a05401.html#a6904ca2a5311bc475d24cd7859dff66b">root</a>, std::ostream &amp;out=std::cout) const</td></tr>
<tr class="memdesc:aaccc2e0eabfaa2e0afbdb8d8f8167810"><td class="mdescLeft">&#160;</td><td class="mdescRight">中序遍历以root为根结点的树(递归版本)  <a href="a05401.html#aaccc2e0eabfaa2e0afbdb8d8f8167810">More...</a><br /></td></tr>
<tr class="separator:aaccc2e0eabfaa2e0afbdb8d8f8167810"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21bb7a7c9def883a6fc6100daee7da93"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05401.html#a21bb7a7c9def883a6fc6100daee7da93">postOrder</a> (<a class="el" href="a05405.html">BinNode</a> *<a class="el" href="a05401.html#a6904ca2a5311bc475d24cd7859dff66b">root</a>, std::ostream &amp;out=std::cout) const</td></tr>
<tr class="memdesc:a21bb7a7c9def883a6fc6100daee7da93"><td class="mdescLeft">&#160;</td><td class="mdescRight">后序遍历以root为根结点的树(递归版本)  <a href="a05401.html#a21bb7a7c9def883a6fc6100daee7da93">More...</a><br /></td></tr>
<tr class="separator:a21bb7a7c9def883a6fc6100daee7da93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c1ead0ecde8fd11ed6d413cb436b746"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a05401.html#af83b64f3ad17abdaab0c208a4c0afafc">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05401.html#a0c1ead0ecde8fd11ed6d413cb436b746">size</a> (<a class="el" href="a05405.html">BinNode</a> *_root) const</td></tr>
<tr class="memdesc:a0c1ead0ecde8fd11ed6d413cb436b746"><td class="mdescLeft">&#160;</td><td class="mdescRight">返回以指定结点为根结点的二叉树的规模(递归版本)  <a href="a05401.html#a0c1ead0ecde8fd11ed6d413cb436b746">More...</a><br /></td></tr>
<tr class="separator:a0c1ead0ecde8fd11ed6d413cb436b746"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acacefce24de297c47729246317719729"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a05401.html#af83b64f3ad17abdaab0c208a4c0afafc">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05401.html#acacefce24de297c47729246317719729">size_loop</a> (<a class="el" href="a05405.html">BinNode</a> *_root) const</td></tr>
<tr class="memdesc:acacefce24de297c47729246317719729"><td class="mdescLeft">&#160;</td><td class="mdescRight">返回以指定结点为根结点的二叉树的规模(非递归版本)  <a href="a05401.html#acacefce24de297c47729246317719729">More...</a><br /></td></tr>
<tr class="separator:acacefce24de297c47729246317719729"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a903b0c460b2763a2334df9b688ab7e13"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a05401.html#af83b64f3ad17abdaab0c208a4c0afafc">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05401.html#a903b0c460b2763a2334df9b688ab7e13">height</a> (<a class="el" href="a05405.html">BinNode</a> *_root) const</td></tr>
<tr class="memdesc:a903b0c460b2763a2334df9b688ab7e13"><td class="mdescLeft">&#160;</td><td class="mdescRight">返回以指定结点为根结点的二叉树的高度(递归版本)  <a href="a05401.html#a903b0c460b2763a2334df9b688ab7e13">More...</a><br /></td></tr>
<tr class="separator:a903b0c460b2763a2334df9b688ab7e13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a952158e7308bee57ec934a3fd292356c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a05401.html#af83b64f3ad17abdaab0c208a4c0afafc">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05401.html#a952158e7308bee57ec934a3fd292356c">height_loop</a> (<a class="el" href="a05405.html">BinNode</a> *_root) const</td></tr>
<tr class="memdesc:a952158e7308bee57ec934a3fd292356c"><td class="mdescLeft">&#160;</td><td class="mdescRight">返回以指定结点为根结点的二叉树的高度(非递归版本)  <a href="a05401.html#a952158e7308bee57ec934a3fd292356c">More...</a><br /></td></tr>
<tr class="separator:a952158e7308bee57ec934a3fd292356c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1189a5975fbb8a44ed1ff746902910d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a05401.html#af83b64f3ad17abdaab0c208a4c0afafc">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05401.html#af1189a5975fbb8a44ed1ff746902910d">CountDegreeTwo</a> (<a class="el" href="a05405.html">BinNode</a> *_root) const</td></tr>
<tr class="memdesc:af1189a5975fbb8a44ed1ff746902910d"><td class="mdescLeft">&#160;</td><td class="mdescRight">统计树中度为2的结点的个数  <a href="a05401.html#af1189a5975fbb8a44ed1ff746902910d">More...</a><br /></td></tr>
<tr class="separator:af1189a5975fbb8a44ed1ff746902910d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac72226f157079d3e873a6412a7f6f9a3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05401.html#ac72226f157079d3e873a6412a7f6f9a3">swaplr</a> (<a class="el" href="a05405.html">BinNode</a> *_root)</td></tr>
<tr class="memdesc:ac72226f157079d3e873a6412a7f6f9a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">交换左右子树  <a href="a05401.html#ac72226f157079d3e873a6412a7f6f9a3">More...</a><br /></td></tr>
<tr class="separator:ac72226f157079d3e873a6412a7f6f9a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-static-methods"></a>
Static Private Member Functions</h2></td></tr>
<tr class="memitem:a9139b8824a1b08e5436685a2dbc6b296"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05401.html#a9139b8824a1b08e5436685a2dbc6b296">is_symmetrical_subtree</a> (<a class="el" href="a05405.html">BinNode</a> *root1, <a class="el" href="a05405.html">BinNode</a> *root2)</td></tr>
<tr class="memdesc:a9139b8824a1b08e5436685a2dbc6b296"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal method to 判断两棵二叉树是否相互对称  <a href="a05401.html#a9139b8824a1b08e5436685a2dbc6b296">More...</a><br /></td></tr>
<tr class="separator:a9139b8824a1b08e5436685a2dbc6b296"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acff903bc85aae48ad28856ab8a990bc4"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05401.html#acff903bc85aae48ad28856ab8a990bc4">value_type_less</a> (const <a class="el" href="a05401.html#afaa28be8afcfed930217d6d75ae18383">value_type</a> &amp;lhs, const <a class="el" href="a05401.html#afaa28be8afcfed930217d6d75ae18383">value_type</a> &amp;rhs)</td></tr>
<tr class="memdesc:acff903bc85aae48ad28856ab8a990bc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">比较value_type类型对象的大小。  <a href="a05401.html#acff903bc85aae48ad28856ab8a990bc4">More...</a><br /></td></tr>
<tr class="separator:acff903bc85aae48ad28856ab8a990bc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addaed7635a0453b38ab8eda812a8d5a0"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05401.html#addaed7635a0453b38ab8eda812a8d5a0">value_type_equal</a> (const <a class="el" href="a05401.html#afaa28be8afcfed930217d6d75ae18383">value_type</a> &amp;lhs, const <a class="el" href="a05401.html#afaa28be8afcfed930217d6d75ae18383">value_type</a> &amp;rhs)</td></tr>
<tr class="memdesc:addaed7635a0453b38ab8eda812a8d5a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">比较value_type类型对象的大小。  <a href="a05401.html#addaed7635a0453b38ab8eda812a8d5a0">More...</a><br /></td></tr>
<tr class="separator:addaed7635a0453b38ab8eda812a8d5a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1811f886d68ab66847e6ceebd91570c3"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05401.html#a1811f886d68ab66847e6ceebd91570c3">value_type_less_equal</a> (const <a class="el" href="a05401.html#afaa28be8afcfed930217d6d75ae18383">value_type</a> &amp;lhs, const <a class="el" href="a05401.html#afaa28be8afcfed930217d6d75ae18383">value_type</a> &amp;rhs)</td></tr>
<tr class="memdesc:a1811f886d68ab66847e6ceebd91570c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">比较value_type类型对象的大小。  <a href="a05401.html#a1811f886d68ab66847e6ceebd91570c3">More...</a><br /></td></tr>
<tr class="separator:a1811f886d68ab66847e6ceebd91570c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a112bcac254c7344802ef74aa561b9c"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05401.html#a7a112bcac254c7344802ef74aa561b9c">is_equal_subtree</a> (<a class="el" href="a05405.html">BinNode</a> *_root1, <a class="el" href="a05405.html">BinNode</a> *_root2)</td></tr>
<tr class="memdesc:a7a112bcac254c7344802ef74aa561b9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">判断两棵二叉树是否相同 "相同"是指：两棵树的形状及对应结点的值相等  <a href="a05401.html#a7a112bcac254c7344802ef74aa561b9c">More...</a><br /></td></tr>
<tr class="separator:a7a112bcac254c7344802ef74aa561b9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:ab518fbeddcd16a35e087ab5ce6bdec16"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a05405.html">BinNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05401.html#ab518fbeddcd16a35e087ab5ce6bdec16">root_</a></td></tr>
<tr class="memdesc:ab518fbeddcd16a35e087ab5ce6bdec16"><td class="mdescLeft">&#160;</td><td class="mdescRight">二叉树的根结点  <a href="a05401.html#ab518fbeddcd16a35e087ab5ce6bdec16">More...</a><br /></td></tr>
<tr class="separator:ab518fbeddcd16a35e087ab5ce6bdec16"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-static-attribs"></a>
Static Private Attributes</h2></td></tr>
<tr class="memitem:a2d83bc4e269a3a8f81db1f6c79824c9e"><td class="memItemLeft" align="right" valign="top">static Comparator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05401.html#a2d83bc4e269a3a8f81db1f6c79824c9e">is_less_than_</a> = Comparator{}</td></tr>
<tr class="memdesc:a2d83bc4e269a3a8f81db1f6c79824c9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">比较器(function object)  <a href="a05401.html#a2d83bc4e269a3a8f81db1f6c79824c9e">More...</a><br /></td></tr>
<tr class="separator:a2d83bc4e269a3a8f81db1f6c79824c9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:af67a715c8762e222910cecaefadc4b26"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05401.html#af67a715c8762e222910cecaefadc4b26">operator==</a> (const <a class="el" href="a05401.html">binaryTree</a> &amp;lhs, const <a class="el" href="a05401.html">binaryTree</a> &amp;rhs)</td></tr>
<tr class="memdesc:af67a715c8762e222910cecaefadc4b26"><td class="mdescLeft">&#160;</td><td class="mdescRight">比较两棵二叉树是否相同 "相同"是指：  <a href="a05401.html#af67a715c8762e222910cecaefadc4b26">More...</a><br /></td></tr>
<tr class="separator:af67a715c8762e222910cecaefadc4b26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93afab389963fd3c1c581ef3ebae3432"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05401.html#a93afab389963fd3c1c581ef3ebae3432">printBinaryTree</a> (const <a class="el" href="a05401.html">binaryTree</a> &amp;bin_tree, const typename <a class="el" href="a05401.html">binaryTree</a> ::<a class="el" href="a05401.html#afaa28be8afcfed930217d6d75ae18383">value_type</a> &amp;flag, std::ostream &amp;out)</td></tr>
<tr class="separator:a93afab389963fd3c1c581ef3ebae3432"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T, typename Comparator&gt;<br />
class Tree::binaryTree&lt; T, Comparator &gt;</h3>

<p>用二叉链表实现的二叉树类 </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>数据类型 </td></tr>
    <tr><td class="paramname">Comparator</td><td>数据类型的比较器类，默认为std::less&lt;T&gt;</td></tr>
  </table>
  </dd>
</dl>
<p>若类型T重载了operator&lt;，则Comparator的默认类型std::less&lt;T&gt;将调用operator&lt;，故实例化时不必指定tparam2；<br  />
否则，要求指定模板参数Comparator，which is a function object, 重载了bool operator(T t1, T t2)：当语义上t1 &lt; t2时返回true。</p>
<p>要求对T重载了operator&lt;&lt; 和 operator&gt;&gt;。建议每个对象的输出在一行以内 </p><dl class="section warning"><dt>Warning</dt><dd>若树中存储了data相同的结点，则私有find方法调用该方法的公有方法可能出现异常！ </dd></dl>

<p class="definition">Definition at line <a class="el" href="a04520_source.html#l00053">53</a> of file <a class="el" href="a04520_source.html">binaryTree.hh</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a165837c10ea2f371ac7989e35acb11b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a165837c10ea2f371ac7989e35acb11b5">&#9670;&nbsp;</a></span>reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Comparator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="a05401.html#afaa28be8afcfed930217d6d75ae18383">value_type</a>&amp; <a class="el" href="a05401.html">Tree::binaryTree</a>&lt; T, Comparator &gt;::<a class="el" href="a05401.html#a165837c10ea2f371ac7989e35acb11b5">reference</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>数据的引用 </p>

<p class="definition">Definition at line <a class="el" href="a04520_source.html#l00109">109</a> of file <a class="el" href="a04520_source.html">binaryTree.hh</a>.</p>

</div>
</div>
<a id="af83b64f3ad17abdaab0c208a4c0afafc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af83b64f3ad17abdaab0c208a4c0afafc">&#9670;&nbsp;</a></span>size_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Comparator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef size_t <a class="el" href="a05401.html">Tree::binaryTree</a>&lt; T, Comparator &gt;::<a class="el" href="a05401.html#af83b64f3ad17abdaab0c208a4c0afafc">size_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>计数器类型 </p>

<p class="definition">Definition at line <a class="el" href="a04520_source.html#l00111">111</a> of file <a class="el" href="a04520_source.html">binaryTree.hh</a>.</p>

</div>
</div>
<a id="afaa28be8afcfed930217d6d75ae18383"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afaa28be8afcfed930217d6d75ae18383">&#9670;&nbsp;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Comparator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef T <a class="el" href="a05401.html">Tree::binaryTree</a>&lt; T, Comparator &gt;::<a class="el" href="a05401.html#afaa28be8afcfed930217d6d75ae18383">value_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>类型别名定义 </p>
<p>数据类型 </p>

<p class="definition">Definition at line <a class="el" href="a04520_source.html#l00108">108</a> of file <a class="el" href="a04520_source.html">binaryTree.hh</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a57bd7d354167f52331f751bf0dab4dc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57bd7d354167f52331f751bf0dab4dc7">&#9670;&nbsp;</a></span>binaryTree() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Comparator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a05401.html">Tree::binaryTree</a>&lt; T, Comparator &gt;::<a class="el" href="a05401.html">binaryTree</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a new binary <a class="el" href="a05445.html">Tree</a> object. </p>
<p>创建一棵空树 </p>

<p class="definition">Definition at line <a class="el" href="a04520_source.html#l00160">160</a> of file <a class="el" href="a04520_source.html">binaryTree.hh</a>.</p>

</div>
</div>
<a id="a3adeeaa5aed3b3d4852c906ff829cab5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3adeeaa5aed3b3d4852c906ff829cab5">&#9670;&nbsp;</a></span>binaryTree() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Comparator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a05401.html">Tree::binaryTree</a>&lt; T, Comparator &gt;::<a class="el" href="a05401.html">binaryTree</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a05401.html#afaa28be8afcfed930217d6d75ae18383">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a new binary <a class="el" href="a05445.html">Tree</a> object. </p>
<p>创建一棵带有根节点的树</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>根结点的数据 </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="a04520_source.html#l00169">169</a> of file <a class="el" href="a04520_source.html">binaryTree.hh</a>.</p>

</div>
</div>
<a id="a30b25e4df45a1148e513f7200da3b1b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30b25e4df45a1148e513f7200da3b1b9">&#9670;&nbsp;</a></span>binaryTree() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Comparator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a05401.html">Tree::binaryTree</a>&lt; T, Comparator &gt;::<a class="el" href="a05401.html">binaryTree</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a05401.html">binaryTree</a>&lt; T, Comparator &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a new binary <a class="el" href="a05445.html">Tree</a> object 拷贝构造函数 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>源对象 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>参考C++设计模式——原型模式 </dd></dl>

<p class="definition">Definition at line <a class="el" href="a04520_source.html#l00177">177</a> of file <a class="el" href="a04520_source.html">binaryTree.hh</a>.</p>

</div>
</div>
<a id="a3b41680a8246aa1c947cad46b984e01e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b41680a8246aa1c947cad46b984e01e">&#9670;&nbsp;</a></span>binaryTree() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Comparator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a05401.html">Tree::binaryTree</a>&lt; T, Comparator &gt;::<a class="el" href="a05401.html">binaryTree</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a05401.html">binaryTree</a>&lt; T, Comparator &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a new binary <a class="el" href="a05445.html">Tree</a> object 移动构造函数 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>源对象，右值 </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="a04520_source.html#l00198">198</a> of file <a class="el" href="a04520_source.html">binaryTree.hh</a>.</p>

</div>
</div>
<a id="a98c1d78d85e836d3424ad66cc2425ee2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98c1d78d85e836d3424ad66cc2425ee2">&#9670;&nbsp;</a></span>~binaryTree()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , typename Comparator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a05401.html">Tree::binaryTree</a>&lt; T, Comparator &gt;::~<a class="el" href="a05401.html">binaryTree</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy the binary <a class="el" href="a05445.html">Tree</a> object. </p>

<p class="definition">Definition at line <a class="el" href="a04520_source.html#l00654">654</a> of file <a class="el" href="a04520_source.html">binaryTree.hh</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a9194d1f92b108620b53180da999aaa48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9194d1f92b108620b53180da999aaa48">&#9670;&nbsp;</a></span>clear() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , typename Comparator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a05401.html">Tree::binaryTree</a>&lt; T, Comparator &gt;::clear</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>清空二叉树 函数返回后，对象的成员root_将被置nullptr </p>

<p class="definition">Definition at line <a class="el" href="a04520_source.html#l00648">648</a> of file <a class="el" href="a04520_source.html">binaryTree.hh</a>.</p>

<p class="reference">References <a class="el" href="a04520_source.html#l00122">Tree::binaryTree&lt; T, Comparator &gt;::BinNode::data</a>, <a class="el" href="a04520_source.html#l00123">Tree::binaryTree&lt; T, Comparator &gt;::BinNode::left</a>, and <a class="el" href="a04520_source.html#l00124">Tree::binaryTree&lt; T, Comparator &gt;::BinNode::right</a>.</p>

</div>
</div>
<a id="a9d02ce7e04ec1724189dbfbaac976dad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d02ce7e04ec1724189dbfbaac976dad">&#9670;&nbsp;</a></span>clear() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , typename Comparator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a05401.html">Tree::binaryTree</a>&lt; T, Comparator &gt;::clear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a05405.html">BinNode</a> *&amp;&#160;</td>
          <td class="paramname"><em>root</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>清空以root为根结点的树，包括清除根结点 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root</td><td>指向目标树的根结点的指针 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>类的工具函数</dd></dl>
<p>函数执行完毕后，root将被置为nullptr </p>

<p class="definition">Definition at line <a class="el" href="a04520_source.html#l00636">636</a> of file <a class="el" href="a04520_source.html">binaryTree.hh</a>.</p>

</div>
</div>
<a id="a42a46bd0bb2f1f4af08fb0bb97c553ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42a46bd0bb2f1f4af08fb0bb97c553ae">&#9670;&nbsp;</a></span>clone()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , typename Comparator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a05401.html">binaryTree</a>&lt; T, Comparator &gt;::<a class="el" href="a05405.html">BinNode</a> * <a class="el" href="a05401.html">Tree::binaryTree</a>&lt; T, Comparator &gt;::clone </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a05405.html">BinNode</a> *&#160;</td>
          <td class="paramname"><em>_root</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Internal method to clone subtree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_root</td><td>指向源二叉树的根结点的指针 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BinNode* 指向新二叉树的根结点的指针 </dd></dl>

<p class="definition">Definition at line <a class="el" href="a04520_source.html#l00660">660</a> of file <a class="el" href="a04520_source.html">binaryTree.hh</a>.</p>

</div>
</div>
<a id="a1203fc03a4506fa073d80545ce1de6a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1203fc03a4506fa073d80545ce1de6a3">&#9670;&nbsp;</a></span>CountDegreeTwo() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Comparator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a05401.html#af83b64f3ad17abdaab0c208a4c0afafc">size_type</a> <a class="el" href="a05401.html">Tree::binaryTree</a>&lt; T, Comparator &gt;::CountDegreeTwo </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>统计树中度为2的结点的个数 </p>

<p class="definition">Definition at line <a class="el" href="a04520_source.html#l00409">409</a> of file <a class="el" href="a04520_source.html">binaryTree.hh</a>.</p>

<p class="reference">Referenced by <a class="el" href="a04562_source.html#l00173">print_test_result()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="a05401_a1203fc03a4506fa073d80545ce1de6a3_icgraph.svg" width="395" height="38"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="af1189a5975fbb8a44ed1ff746902910d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1189a5975fbb8a44ed1ff746902910d">&#9670;&nbsp;</a></span>CountDegreeTwo() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , typename Comparator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a05401.html">binaryTree</a>&lt; T, Comparator &gt;::<a class="el" href="a05401.html#af83b64f3ad17abdaab0c208a4c0afafc">size_type</a> <a class="el" href="a05401.html">Tree::binaryTree</a>&lt; T, Comparator &gt;::CountDegreeTwo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a05405.html">BinNode</a> *&#160;</td>
          <td class="paramname"><em>_root</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>统计树中度为2的结点的个数 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_root</td><td>指向树的根结点的指针 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>类的工具函数 </dd></dl>

<p class="definition">Definition at line <a class="el" href="a04520_source.html#l01082">1082</a> of file <a class="el" href="a04520_source.html">binaryTree.hh</a>.</p>

</div>
</div>
<a id="a40668a92e598befe619d6e1ffe5f2a52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40668a92e598befe619d6e1ffe5f2a52">&#9670;&nbsp;</a></span>createTree()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , typename Comparator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a05401.html">Tree::binaryTree</a>&lt; T, Comparator &gt;::createTree </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a05401.html#afaa28be8afcfed930217d6d75ae18383">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>flag</em> = <code><a class="el" href="a05401.html#afaa28be8afcfed930217d6d75ae18383">value_type</a>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em> = <code>std::cin</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a <a class="el" href="a05445.html">Tree</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flag</td><td>"空结点"的特殊标记 </td></tr>
    <tr><td class="paramname">in</td><td>输入流对象，可以是cin, 或者ifstream类的对象等</td></tr>
  </table>
  </dd>
</dl>
<p>@ details 该方法首先调用clear()清空二叉树。 然后要从输入流(标准/文件流)按层次顺序输入在建二叉树各结点的值，依此建立一棵二叉树<br  />
输入flag表示"空结点" </p><dl class="section warning"><dt>Warning</dt><dd>本方法可能调用ifstream类从istream类继承的的sync()方法，which可能导致未定义行为。 </dd></dl>
<dl class="section note"><dt>Note</dt><dd>要求对value_type类型重载了operator&gt;&gt;和operator&lt;&lt; </dd></dl>

<p class="definition">Definition at line <a class="el" href="a04520_source.html#l01324">1324</a> of file <a class="el" href="a04520_source.html">binaryTree.hh</a>.</p>

<p class="reference">Referenced by <a class="el" href="a04559_source.html#l00050">main()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="a05401_a40668a92e598befe619d6e1ffe5f2a52_icgraph.svg" width="294" height="38"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="aadacd70978bd8a75adc9ef2c4f6f40e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadacd70978bd8a75adc9ef2c4f6f40e4">&#9670;&nbsp;</a></span>delLeft()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , typename Comparator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a05401.html">Tree::binaryTree</a>&lt; T, Comparator &gt;::delLeft </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a05401.html#afaa28be8afcfed930217d6d75ae18383">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>删除左subtree </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>目标结点。以该结点的左child为根的树将被删除 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>树中有data相同的结点时，该方法只能访问到前序序列中首次出现该数据的那个结点！ </dd></dl>

<p class="definition">Definition at line <a class="el" href="a04520_source.html#l01031">1031</a> of file <a class="el" href="a04520_source.html">binaryTree.hh</a>.</p>

<p class="reference">Referenced by <a class="el" href="a04571_source.html#l00051">main()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="a05401_aadacd70978bd8a75adc9ef2c4f6f40e4_icgraph.svg" width="271" height="38"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="ad960b8028f5d1d8c9282160aede6f68b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad960b8028f5d1d8c9282160aede6f68b">&#9670;&nbsp;</a></span>delRight()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , typename Comparator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a05401.html">Tree::binaryTree</a>&lt; T, Comparator &gt;::delRight </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a05401.html#afaa28be8afcfed930217d6d75ae18383">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>删除右subtree </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>目标结点。以该节点的右child为根的树将被删除 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>树中有data相同的结点时，该方法只能访问到前序序列中首次出现该数据的那个结点！ </dd></dl>

<p class="definition">Definition at line <a class="el" href="a04520_source.html#l01041">1041</a> of file <a class="el" href="a04520_source.html">binaryTree.hh</a>.</p>

<p class="reference">Referenced by <a class="el" href="a04571_source.html#l00051">main()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="a05401_ad960b8028f5d1d8c9282160aede6f68b_icgraph.svg" width="280" height="38"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a3496f157e966e3acc0bfc97d0b9854b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3496f157e966e3acc0bfc97d0b9854b0">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , typename Comparator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a05401.html">Tree::binaryTree</a>&lt; T, Comparator &gt;::empty</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>判断二叉树是否为空树 </p>
<dl class="section return"><dt>Returns</dt><dd>true 是空树 </dd>
<dd>
false 非空树 </dd></dl>

<p class="definition">Definition at line <a class="el" href="a04520_source.html#l00621">621</a> of file <a class="el" href="a04520_source.html">binaryTree.hh</a>.</p>

</div>
</div>
<a id="a8c8d3f85b7ce46148d672e722c8a7c5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c8d3f85b7ce46148d672e722c8a7c5a">&#9670;&nbsp;</a></span>find()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , typename Comparator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a05401.html">binaryTree</a>&lt; T, Comparator &gt;::<a class="el" href="a05405.html">BinNode</a> * <a class="el" href="a05401.html">Tree::binaryTree</a>&lt; T, Comparator &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a05401.html#afaa28be8afcfed930217d6d75ae18383">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a05405.html">BinNode</a> *&#160;</td>
          <td class="paramname"><em>root</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>在以root为根的树中(前序)查找数据为x的结点，返回指向该结点的指针 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>目标数据 </td></tr>
    <tr><td class="paramname">root</td><td>目标二叉树的根结点的地址 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BinNode* 指向查找到的数据为x的结点的指针。返回nullptr表示找不到。</dd></dl>
<dl class="section note"><dt>Note</dt><dd>类的工具函数 </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>树中有data相同的结点时，该方法只能找到前序序列中首次出现该数据的那个结点！ </dd></dl>

<p class="definition">Definition at line <a class="el" href="a04520_source.html#l01015">1015</a> of file <a class="el" href="a04520_source.html">binaryTree.hh</a>.</p>

</div>
</div>
<a id="ac7389dcd912456fbc77ad350a1134732"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7389dcd912456fbc77ad350a1134732">&#9670;&nbsp;</a></span>height() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , typename Comparator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a05401.html">binaryTree</a>&lt; T, Comparator &gt;::<a class="el" href="a05401.html#af83b64f3ad17abdaab0c208a4c0afafc">size_type</a> <a class="el" href="a05401.html">Tree::binaryTree</a>&lt; T, Comparator &gt;::height</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>返回二叉树的高度(递归版本) </p>
<p>The height of n_i is the length of the longest path from n_i to a leaf. Thus all leaves are at height 0. <br  />
The height of a tree is equal to the height of the root.</p>
<dl class="section return"><dt>Returns</dt><dd>size_type 二叉树的高度 </dd></dl>

<p class="definition">Definition at line <a class="el" href="a04520_source.html#l01195">1195</a> of file <a class="el" href="a04520_source.html">binaryTree.hh</a>.</p>

<p class="reference">Referenced by <a class="el" href="a04559_source.html#l00175">print_test_result()</a>, and <a class="el" href="a04544_source.html#l00108">Tree::print_test_result()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="a05401_ac7389dcd912456fbc77ad350a1134732_icgraph.svg" width="464" height="88"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a903b0c460b2763a2334df9b688ab7e13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a903b0c460b2763a2334df9b688ab7e13">&#9670;&nbsp;</a></span>height() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , typename Comparator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a05401.html">binaryTree</a>&lt; T, Comparator &gt;::<a class="el" href="a05401.html#af83b64f3ad17abdaab0c208a4c0afafc">size_type</a> <a class="el" href="a05401.html">Tree::binaryTree</a>&lt; T, Comparator &gt;::height </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a05405.html">BinNode</a> *&#160;</td>
          <td class="paramname"><em>_root</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>返回以指定结点为根结点的二叉树的高度(递归版本) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_root</td><td>指向根结点的指针 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>value_type 以指定结点为根结点的二叉树的高度 </dd></dl>
<dl class="section note"><dt>Note</dt><dd>类的工具函数 </dd></dl>

<p class="definition">Definition at line <a class="el" href="a04520_source.html#l01093">1093</a> of file <a class="el" href="a04520_source.html">binaryTree.hh</a>.</p>

</div>
</div>
<a id="a18c50f432143bfe2feade7347f8ff770"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18c50f432143bfe2feade7347f8ff770">&#9670;&nbsp;</a></span>height_loop() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , typename Comparator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a05401.html">binaryTree</a>&lt; T, Comparator &gt;::<a class="el" href="a05401.html#af83b64f3ad17abdaab0c208a4c0afafc">size_type</a> <a class="el" href="a05401.html">Tree::binaryTree</a>&lt; T, Comparator &gt;::height_loop</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>返回二叉树的高度(非递归版本) </p>
<p>The height of n_i is the length of the longest path from n_i to a leaf. Thus all leaves are at height 0. <br  />
The height of a tree is equal to the height of the root.</p>
<dl class="section return"><dt>Returns</dt><dd>size_type 二叉树的高度 </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Reference <a href="https://www.codeproject.com/Articles/418776/How-to-replace-recursive-functions-using-stack-and">https://www.codeproject.com/Articles/418776/How-to-replace-recursive-functions-using-stack-and</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="a04520_source.html#l01201">1201</a> of file <a class="el" href="a04520_source.html">binaryTree.hh</a>.</p>

<p class="reference">Referenced by <a class="el" href="a04559_source.html#l00175">print_test_result()</a>, and <a class="el" href="a04544_source.html#l00108">Tree::print_test_result()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="a05401_a18c50f432143bfe2feade7347f8ff770_icgraph.svg" width="495" height="88"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a952158e7308bee57ec934a3fd292356c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a952158e7308bee57ec934a3fd292356c">&#9670;&nbsp;</a></span>height_loop() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , typename Comparator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a05401.html">binaryTree</a>&lt; T, Comparator &gt;::<a class="el" href="a05401.html#af83b64f3ad17abdaab0c208a4c0afafc">size_type</a> <a class="el" href="a05401.html">Tree::binaryTree</a>&lt; T, Comparator &gt;::height_loop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a05405.html">BinNode</a> *&#160;</td>
          <td class="paramname"><em>_root</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>返回以指定结点为根结点的二叉树的高度(非递归版本) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_root</td><td>指向根结点的指针 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>value_type 以指定结点为根结点的二叉树的高度 </dd></dl>
<dl class="section note"><dt>Note</dt><dd>类的工具函数 </dd>
<dd>
Reference <a href="https://www.codeproject.com/Articles/418776/How-to-replace-recursive-functions-using-stack-and">https://www.codeproject.com/Articles/418776/How-to-replace-recursive-functions-using-stack-and</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="a04520_source.html#l01104">1104</a> of file <a class="el" href="a04520_source.html">binaryTree.hh</a>.</p>

</div>
</div>
<a id="aaccc2e0eabfaa2e0afbdb8d8f8167810"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaccc2e0eabfaa2e0afbdb8d8f8167810">&#9670;&nbsp;</a></span>inOrder() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , typename Comparator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a05401.html">Tree::binaryTree</a>&lt; T, Comparator &gt;::inOrder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a05405.html">BinNode</a> *&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em> = <code>std::cout</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>中序遍历以root为根结点的树(递归版本) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root</td><td>指向目标树的根结点的指针 </td></tr>
    <tr><td class="paramname">out</td><td>输出流对象，可以是标准输出流或文件流等 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>类的工具函数 </dd></dl>

<p class="definition">Definition at line <a class="el" href="a04520_source.html#l00837">837</a> of file <a class="el" href="a04520_source.html">binaryTree.hh</a>.</p>

</div>
</div>
<a id="ac6003da876c500af081001c549a90433"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6003da876c500af081001c549a90433">&#9670;&nbsp;</a></span>inOrder() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , typename Comparator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a05401.html">Tree::binaryTree</a>&lt; T, Comparator &gt;::inOrder </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em> = <code>std::cout</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>中序遍历(递归版本) </p>
<p>中序打印二叉树各结点的数据到标准输出设备 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>输出流对象，可以是标准输出流或文件流等 </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="a04520_source.html#l00906">906</a> of file <a class="el" href="a04520_source.html">binaryTree.hh</a>.</p>

<p class="reference">Referenced by <a class="el" href="a04559_source.html#l00175">print_test_result()</a>, and <a class="el" href="a04544_source.html#l00108">Tree::print_test_result()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="a05401_ac6003da876c500af081001c549a90433_icgraph.svg" width="471" height="88"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a6cb786410ed6c0f61969a09b76f4da0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cb786410ed6c0f61969a09b76f4da0c">&#9670;&nbsp;</a></span>inOrder_loop()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , typename Comparator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a05401.html">Tree::binaryTree</a>&lt; T, Comparator &gt;::inOrder_loop </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em> = <code>std::cout</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>中序遍历(非递归版本) </p>
<p>中序打印二叉树各结点的数据到标准输出设备 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>输出流对象，可以是标准输出流或文件流等 </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="a04520_source.html#l00848">848</a> of file <a class="el" href="a04520_source.html">binaryTree.hh</a>.</p>

<p class="reference">Referenced by <a class="el" href="a04559_source.html#l00175">print_test_result()</a>, and <a class="el" href="a04544_source.html#l00108">Tree::print_test_result()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="a05401_a6cb786410ed6c0f61969a09b76f4da0c_icgraph.svg" width="502" height="88"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a7a112bcac254c7344802ef74aa561b9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a112bcac254c7344802ef74aa561b9c">&#9670;&nbsp;</a></span>is_equal_subtree()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a05401.html">Tree::binaryTree</a>&lt; T, U &gt;::is_equal_subtree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a05405.html">BinNode</a> *&#160;</td>
          <td class="paramname"><em>_root1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a05405.html">BinNode</a> *&#160;</td>
          <td class="paramname"><em>_root2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>判断两棵二叉树是否相同 "相同"是指：两棵树的形状及对应结点的值相等 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_root1</td><td>指向二叉树#1的根结点的指针 </td></tr>
    <tr><td class="paramname">_root2</td><td>指向二叉树#2的根结点的指针 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true 两棵树相同 </dd>
<dd>
false 两棵树不相同 </dd></dl>

<p class="definition">Definition at line <a class="el" href="a04520_source.html#l00684">684</a> of file <a class="el" href="a04520_source.html">binaryTree.hh</a>.</p>

</div>
</div>
<a id="a9139b8824a1b08e5436685a2dbc6b296"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9139b8824a1b08e5436685a2dbc6b296">&#9670;&nbsp;</a></span>is_symmetrical_subtree()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a05401.html">Tree::binaryTree</a>&lt; T, U &gt;::is_symmetrical_subtree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a05405.html">BinNode</a> *&#160;</td>
          <td class="paramname"><em>root1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a05405.html">BinNode</a> *&#160;</td>
          <td class="paramname"><em>root2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Internal method to 判断两棵二叉树是否相互对称 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root1</td><td>指向二叉树#1的根结点的指针 </td></tr>
    <tr><td class="paramname">root2</td><td>指向二叉树#2的根结点的指针 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true #1和#2相互对称 </dd>
<dd>
false otherwise </dd></dl>

<p class="definition">Definition at line <a class="el" href="a04520_source.html#l00668">668</a> of file <a class="el" href="a04520_source.html">binaryTree.hh</a>.</p>

</div>
</div>
<a id="a31c21bc3323bcc69b5053c325aacf015"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31c21bc3323bcc69b5053c325aacf015">&#9670;&nbsp;</a></span>is_symmetrical_tree()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Comparator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool <a class="el" href="a05401.html">Tree::binaryTree</a>&lt; T, Comparator &gt;::is_symmetrical_tree </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a05401.html">binaryTree</a>&lt; T, Comparator &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a05401.html">binaryTree</a>&lt; T, Comparator &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>判断两棵二叉树是否互为镜像 两棵二叉树#1和#2互为镜像，如果二者皆为空树；或二者根结点的值相同，且#1的左、右子树与#2的右、左子树互为镜像 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>二叉树#1 </td></tr>
    <tr><td class="paramname">rhs</td><td>二叉树#2 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true #1 symmetrical to #2 </dd>
<dd>
false otherwise </dd></dl>

<p class="definition">Definition at line <a class="el" href="a04520_source.html#l00437">437</a> of file <a class="el" href="a04520_source.html">binaryTree.hh</a>.</p>

</div>
</div>
<a id="a2b05f46a36ae7f0f98dfa65dc908fdca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b05f46a36ae7f0f98dfa65dc908fdca">&#9670;&nbsp;</a></span>isCompleteTree()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , typename Comparator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a05401.html">Tree::binaryTree</a>&lt; T, Comparator &gt;::isCompleteTree</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>返回是否完全二叉树 </p>
<dl class="section return"><dt>Returns</dt><dd>true 是完全二叉树 </dd>
<dd>
false 不是完全二叉树 </dd></dl>
<p>至此，当前结点处理完毕。 若当前结点有空孩子，则它是层序上的首个度非2结点。 从而是完全二叉树iff.其后(不含)的结点全为叶子结点。</p>
<p>函数只可能在此if中返回</p>

<p class="definition">Definition at line <a class="el" href="a04520_source.html#l00711">711</a> of file <a class="el" href="a04520_source.html">binaryTree.hh</a>.</p>

<p class="reference">References <a class="el" href="a04520_source.html#l00123">Tree::binaryTree&lt; T, Comparator &gt;::BinNode::left</a>, and <a class="el" href="a04520_source.html#l00124">Tree::binaryTree&lt; T, Comparator &gt;::BinNode::right</a>.</p>

<p class="reference">Referenced by <a class="el" href="a04565_source.html#l00182">print_test_result()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="a05401_a2b05f46a36ae7f0f98dfa65dc908fdca_icgraph.svg" width="387" height="38"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="afee39e46bd46f7178347eaae0581063b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afee39e46bd46f7178347eaae0581063b">&#9670;&nbsp;</a></span>isFullBinaryTree()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a05401.html">Tree::binaryTree</a>&lt; T, U &gt;::isFullBinaryTree</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>是否满二叉树 </p>
<dl class="section note"><dt>Note</dt><dd>定义满二叉树：任意一层的结点数都达到了最大值。</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>true 是满二叉树 </dd>
<dd>
false 非满二叉树 </dd></dl>

<p class="definition">Definition at line <a class="el" href="a04520_source.html#l00699">699</a> of file <a class="el" href="a04520_source.html">binaryTree.hh</a>.</p>

<p class="reference">References <a class="el" href="a04535_source.html#l00262">Queue::seqQueue&lt; T &gt;::push()</a>.</p>

<p class="reference">Referenced by <a class="el" href="a04565_source.html#l00182">print_test_result()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="a05401_afee39e46bd46f7178347eaae0581063b_cgraph.svg" width="376" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="a05401_afee39e46bd46f7178347eaae0581063b_icgraph.svg" width="328" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a1a40ebe3b6ce6854040202e4fb5c0f05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a40ebe3b6ce6854040202e4fb5c0f05">&#9670;&nbsp;</a></span>lchild()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , typename Comparator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a05401.html">binaryTree</a>&lt; T, Comparator &gt;::<a class="el" href="a05401.html#afaa28be8afcfed930217d6d75ae18383">value_type</a> <a class="el" href="a05401.html">Tree::binaryTree</a>&lt; T, Comparator &gt;::lchild </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a05401.html#afaa28be8afcfed930217d6d75ae18383">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a05401.html#afaa28be8afcfed930217d6d75ae18383">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>获得数据为x的结点的左child </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>目标结点的数据 </td></tr>
    <tr><td class="paramname">flag</td><td>无左child时返回的标记 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>value_type 左child的数据 </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>树中有data相同的结点时，该方法只能访问到前序序列中首次出现该数据的那个结点！ </dd></dl>

<p class="definition">Definition at line <a class="el" href="a04520_source.html#l01051">1051</a> of file <a class="el" href="a04520_source.html">binaryTree.hh</a>.</p>

</div>
</div>
<a id="a94dcc51623e366cb26fa5e543b19c6f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94dcc51623e366cb26fa5e543b19c6f8">&#9670;&nbsp;</a></span>levelOrder()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , typename Comparator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a05401.html">Tree::binaryTree</a>&lt; T, Comparator &gt;::levelOrder </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em> = <code>std::cout</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>层次遍历 </p>
<p>层次打印二叉树各结点的数据到标准输出设备 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>输出流对象，可以是标准输出流或文件流等 </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="a04520_source.html#l00990">990</a> of file <a class="el" href="a04520_source.html">binaryTree.hh</a>.</p>

<p class="reference">Referenced by <a class="el" href="a04559_source.html#l00175">print_test_result()</a>, and <a class="el" href="a04544_source.html#l00108">Tree::print_test_result()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="a05401_a94dcc51623e366cb26fa5e543b19c6f8_icgraph.svg" width="486" height="88"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="aa3d64f5301306cc864a5138ae1761952"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3d64f5301306cc864a5138ae1761952">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Comparator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a05401.html">binaryTree</a>&amp; <a class="el" href="a05401.html">Tree::binaryTree</a>&lt; T, Comparator &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a05401.html">binaryTree</a>&lt; T, Comparator &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>移动赋值运算符 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>源对象，右值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="a05401.html" title="用二叉链表实现的二叉树类">binaryTree</a>&amp; 目的对象的引用 </dd></dl>

<p class="definition">Definition at line <a class="el" href="a04520_source.html#l00206">206</a> of file <a class="el" href="a04520_source.html">binaryTree.hh</a>.</p>

</div>
</div>
<a id="a09214bfe65861c9ff6ea1534429d03cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09214bfe65861c9ff6ea1534429d03cb">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Comparator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a05401.html">binaryTree</a>&amp; <a class="el" href="a05401.html">Tree::binaryTree</a>&lt; T, Comparator &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a05401.html">binaryTree</a>&lt; T, Comparator &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>赋值运算符重载 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>源对象 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="a05401.html" title="用二叉链表实现的二叉树类">binaryTree</a>&amp; 目的对象的引用 </dd></dl>

<p class="definition">Definition at line <a class="el" href="a04520_source.html#l00185">185</a> of file <a class="el" href="a04520_source.html">binaryTree.hh</a>.</p>

</div>
</div>
<a id="a04b72fb96511872389c079dcdd8dcd39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04b72fb96511872389c079dcdd8dcd39">&#9670;&nbsp;</a></span>parent()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Comparator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a05401.html#afaa28be8afcfed930217d6d75ae18383">value_type</a> <a class="el" href="a05401.html">Tree::binaryTree</a>&lt; T, Comparator &gt;::parent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a05401.html#afaa28be8afcfed930217d6d75ae18383">value_type</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a05401.html#afaa28be8afcfed930217d6d75ae18383">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>返回数据为x的结点的parent结点 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>目标结点的数据 </td></tr>
    <tr><td class="paramname">flag</td><td>parent不存在时返回的特殊标记 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>value_type parent结点的数据</dd></dl>
<dl class="bug"><dt><b><a class="el" href="a04581.html#_bug000002">Bug:</a></b></dt><dd>二叉链表不允许访问结点的parent，本函数恒返回flag </dd></dl>

<p class="definition">Definition at line <a class="el" href="a04520_source.html#l00358">358</a> of file <a class="el" href="a04520_source.html">binaryTree.hh</a>.</p>

</div>
</div>
<a id="a21bb7a7c9def883a6fc6100daee7da93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21bb7a7c9def883a6fc6100daee7da93">&#9670;&nbsp;</a></span>postOrder() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , typename Comparator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a05401.html">Tree::binaryTree</a>&lt; T, Comparator &gt;::postOrder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a05405.html">BinNode</a> *&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em> = <code>std::cout</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>后序遍历以root为根结点的树(递归版本) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root</td><td>指向目标树的根结点的指针 </td></tr>
    <tr><td class="paramname">out</td><td>输出流对象，可以是标准输出流或文件流等 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>类的工具函数 </dd></dl>

<p class="definition">Definition at line <a class="el" href="a04520_source.html#l00912">912</a> of file <a class="el" href="a04520_source.html">binaryTree.hh</a>.</p>

</div>
</div>
<a id="a29e131a4f32bf7ac33dad9cd60d5ca7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29e131a4f32bf7ac33dad9cd60d5ca7b">&#9670;&nbsp;</a></span>postOrder() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , typename Comparator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a05401.html">Tree::binaryTree</a>&lt; T, Comparator &gt;::postOrder </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em> = <code>std::cout</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>后序遍历(递归版本) </p>
<p>后序打印二叉树各结点的数据到标准输出设备 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>输出流对象，可以是标准输出流或文件流等 </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="a04520_source.html#l00984">984</a> of file <a class="el" href="a04520_source.html">binaryTree.hh</a>.</p>

<p class="reference">Referenced by <a class="el" href="a04559_source.html#l00175">print_test_result()</a>, and <a class="el" href="a04544_source.html#l00108">Tree::print_test_result()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="a05401_a29e131a4f32bf7ac33dad9cd60d5ca7b_icgraph.svg" width="486" height="88"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a24d90fc12dae5213ddb8b21baf14cc66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24d90fc12dae5213ddb8b21baf14cc66">&#9670;&nbsp;</a></span>postOrder_loop()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , typename Comparator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a05401.html">Tree::binaryTree</a>&lt; T, Comparator &gt;::postOrder_loop </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em> = <code>std::cout</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>后序遍历(非递归版本) </p>
<p>后序打印二叉树各结点的数据到标准输出设备 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>输出流对象，可以是标准输出流或文件流等 </td></tr>
  </table>
  </dd>
</dl>
<p>连续递归调用，归入一个stage，直接反序进栈即可</p>

<p class="definition">Definition at line <a class="el" href="a04520_source.html#l00923">923</a> of file <a class="el" href="a04520_source.html">binaryTree.hh</a>.</p>

<p class="reference">Referenced by <a class="el" href="a04559_source.html#l00175">print_test_result()</a>, and <a class="el" href="a04544_source.html#l00108">Tree::print_test_result()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="a05401_a24d90fc12dae5213ddb8b21baf14cc66_icgraph.svg" width="516" height="88"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="afcd5d328b700cd21fe3b83a9389afbff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcd5d328b700cd21fe3b83a9389afbff">&#9670;&nbsp;</a></span>preOrder() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , typename Comparator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a05401.html">Tree::binaryTree</a>&lt; T, Comparator &gt;::preOrder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a05405.html">BinNode</a> *&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em> = <code>std::cout</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>前序遍历以root为根结点的树(递归版本) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root</td><td>指向目标树的根结点的指针 </td></tr>
    <tr><td class="paramname">out</td><td>输出流对象，可以是标准输出流或文件流等 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>类的工具函数 </dd></dl>

<p class="definition">Definition at line <a class="el" href="a04520_source.html#l00758">758</a> of file <a class="el" href="a04520_source.html">binaryTree.hh</a>.</p>

</div>
</div>
<a id="aa0a3d9e4bc6035a9c914e5109d6688b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0a3d9e4bc6035a9c914e5109d6688b7">&#9670;&nbsp;</a></span>preOrder() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , typename Comparator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a05401.html">Tree::binaryTree</a>&lt; T, Comparator &gt;::preOrder </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em> = <code>std::cout</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>前序遍历(递归版本) </p>
<p>前序打印二叉树各结点的数据到标准输出设备 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>输出流对象，可以是标准输出流或文件流等 </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="a04520_source.html#l00831">831</a> of file <a class="el" href="a04520_source.html">binaryTree.hh</a>.</p>

<p class="reference">Referenced by <a class="el" href="a04559_source.html#l00175">print_test_result()</a>, and <a class="el" href="a04544_source.html#l00108">Tree::print_test_result()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="a05401_aa0a3d9e4bc6035a9c914e5109d6688b7_icgraph.svg" width="479" height="88"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="af9d71e1c10511c865aed5c553ac24b72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9d71e1c10511c865aed5c553ac24b72">&#9670;&nbsp;</a></span>preOrder_loop()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , typename Comparator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a05401.html">Tree::binaryTree</a>&lt; T, Comparator &gt;::preOrder_loop </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em> = <code>std::cout</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>前序遍历(非递归版本) </p>
<p>前序打印二叉树各结点的数据到标准输出设备 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>输出流对象，可以是标准输出流或文件流等 </td></tr>
  </table>
  </dd>
</dl>
<p>引用类型的形参不需要记录。 只需记录BinNode* _root。 首次调用时，实参就是对象的根结点root_； 该细节应被封装，故提供给用户的函数形参表不设_root。 递归版本是有限次tail recursion，不必记录stage。</p>
<p>首次调用时，实参就是对象的根结点root_； 该细节应被封装，故提供给用户的函数形参表不设_root。</p>
<p>函数体内的递归调用返回后，唯一的行为是新的递归调用， 故不必保存断点(分stage)，直接将所有tail recursions按反序进栈即可。 注意到若某次递归调用的实参为0将导致空操作，所以若为空则不必进栈 (导致两次访问，可选)。</p>

<p class="definition">Definition at line <a class="el" href="a04520_source.html#l00769">769</a> of file <a class="el" href="a04520_source.html">binaryTree.hh</a>.</p>

<p class="reference">Referenced by <a class="el" href="a04559_source.html#l00175">print_test_result()</a>, and <a class="el" href="a04544_source.html#l00108">Tree::print_test_result()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="a05401_af9d71e1c10511c865aed5c553ac24b72_icgraph.svg" width="510" height="88"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="ab0bcb9734e8955c6b1e982d584320f64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0bcb9734e8955c6b1e982d584320f64">&#9670;&nbsp;</a></span>rchild()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , typename Comparator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a05401.html">binaryTree</a>&lt; T, Comparator &gt;::<a class="el" href="a05401.html#afaa28be8afcfed930217d6d75ae18383">value_type</a> <a class="el" href="a05401.html">Tree::binaryTree</a>&lt; T, Comparator &gt;::rchild </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a05401.html#afaa28be8afcfed930217d6d75ae18383">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a05401.html#afaa28be8afcfed930217d6d75ae18383">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>获得数据为x的结点的右child </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>目标结点的数据 </td></tr>
    <tr><td class="paramname">flag</td><td>无右child时返回的标记 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>value_type 右child的数据 </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>树中有data相同的结点时，该方法只能访问到前序序列中首次出现该数据的那个结点！ </dd></dl>

<p class="definition">Definition at line <a class="el" href="a04520_source.html#l01061">1061</a> of file <a class="el" href="a04520_source.html">binaryTree.hh</a>.</p>

<p class="reference">Referenced by <a class="el" href="a04520_source.html#l01426">Tree::printBinaryTree()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="a05401_ab0bcb9734e8955c6b1e982d584320f64_icgraph.svg" width="651" height="88"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a6904ca2a5311bc475d24cd7859dff66b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6904ca2a5311bc475d24cd7859dff66b">&#9670;&nbsp;</a></span>root()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , typename Comparator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a05401.html">binaryTree</a>&lt; T, Comparator &gt;::<a class="el" href="a05401.html#afaa28be8afcfed930217d6d75ae18383">value_type</a> <a class="el" href="a05401.html">Tree::binaryTree</a>&lt; T, Comparator &gt;::root </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a05401.html#afaa28be8afcfed930217d6d75ae18383">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>flag</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>返回根结点的数据 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flag</td><td>为空树时返回的特殊标记 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>value_type 根结点的数据 </dd></dl>

<p class="definition">Definition at line <a class="el" href="a04520_source.html#l00627">627</a> of file <a class="el" href="a04520_source.html">binaryTree.hh</a>.</p>

</div>
</div>
<a id="af2559965baee16c7a496049bccf703af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2559965baee16c7a496049bccf703af">&#9670;&nbsp;</a></span>size() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , typename Comparator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a05401.html">binaryTree</a>&lt; T, Comparator &gt;::<a class="el" href="a05401.html#af83b64f3ad17abdaab0c208a4c0afafc">size_type</a> <a class="el" href="a05401.html">Tree::binaryTree</a>&lt; T, Comparator &gt;::size</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>返回二叉树的结点数(递归版本) </p>
<dl class="section return"><dt>Returns</dt><dd>size_type 二叉树的结点数 </dd></dl>

<p class="definition">Definition at line <a class="el" href="a04520_source.html#l01312">1312</a> of file <a class="el" href="a04520_source.html">binaryTree.hh</a>.</p>

<p class="reference">Referenced by <a class="el" href="a04559_source.html#l00175">print_test_result()</a>, and <a class="el" href="a04544_source.html#l00108">Tree::print_test_result()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="a05401_af2559965baee16c7a496049bccf703af_icgraph.svg" width="452" height="88"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a0c1ead0ecde8fd11ed6d413cb436b746"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c1ead0ecde8fd11ed6d413cb436b746">&#9670;&nbsp;</a></span>size() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , typename Comparator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a05401.html">binaryTree</a>&lt; T, Comparator &gt;::<a class="el" href="a05401.html#af83b64f3ad17abdaab0c208a4c0afafc">size_type</a> <a class="el" href="a05401.html">Tree::binaryTree</a>&lt; T, Comparator &gt;::size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a05405.html">BinNode</a> *&#160;</td>
          <td class="paramname"><em>_root</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>返回以指定结点为根结点的二叉树的规模(递归版本) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_root</td><td>指向根结点的指针 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>value_type 以指定结点为根结点的二叉树的规模 </dd></dl>
<dl class="section note"><dt>Note</dt><dd>类的工具函数 </dd></dl>

<p class="definition">Definition at line <a class="el" href="a04520_source.html#l01207">1207</a> of file <a class="el" href="a04520_source.html">binaryTree.hh</a>.</p>

</div>
</div>
<a id="afe73f325fd03d9281d0330b7a2d0c8a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe73f325fd03d9281d0330b7a2d0c8a8">&#9670;&nbsp;</a></span>size_loop() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , typename Comparator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a05401.html">binaryTree</a>&lt; T, Comparator &gt;::<a class="el" href="a05401.html#af83b64f3ad17abdaab0c208a4c0afafc">size_type</a> <a class="el" href="a05401.html">Tree::binaryTree</a>&lt; T, Comparator &gt;::size_loop</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>返回二叉树的结点数(非递归版本) </p>
<dl class="section return"><dt>Returns</dt><dd>size_type 二叉树的结点数 </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Reference <a href="https://www.codeproject.com/Articles/418776/How-to-replace-recursive-functions-using-stack-and">https://www.codeproject.com/Articles/418776/How-to-replace-recursive-functions-using-stack-and</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="a04520_source.html#l01318">1318</a> of file <a class="el" href="a04520_source.html">binaryTree.hh</a>.</p>

<p class="reference">Referenced by <a class="el" href="a04559_source.html#l00175">print_test_result()</a>, and <a class="el" href="a04544_source.html#l00108">Tree::print_test_result()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="a05401_afe73f325fd03d9281d0330b7a2d0c8a8_icgraph.svg" width="484" height="88"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="acacefce24de297c47729246317719729"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acacefce24de297c47729246317719729">&#9670;&nbsp;</a></span>size_loop() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , typename Comparator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a05401.html">binaryTree</a>&lt; T, Comparator &gt;::<a class="el" href="a05401.html#af83b64f3ad17abdaab0c208a4c0afafc">size_type</a> <a class="el" href="a05401.html">Tree::binaryTree</a>&lt; T, Comparator &gt;::size_loop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a05405.html">BinNode</a> *&#160;</td>
          <td class="paramname"><em>_root</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>返回以指定结点为根结点的二叉树的规模(非递归版本) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_root</td><td>指向根结点的指针 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>value_type 以指定结点为根结点的二叉树的规模 </dd></dl>
<dl class="section note"><dt>Note</dt><dd>类的工具函数 </dd></dl>
<h1><a class="anchor" id="Reference"></a>
Reference</h1>
<p><a href="https://www.codeproject.com/Articles/418776/How-to-replace-recursive-functions-using-stack-and">https://www.codeproject.com/Articles/418776/How-to-replace-recursive-functions-using-stack-and</a> </p>

<p class="definition">Definition at line <a class="el" href="a04520_source.html#l01220">1220</a> of file <a class="el" href="a04520_source.html">binaryTree.hh</a>.</p>

</div>
</div>
<a id="a81357f9d197b142b8126579ce51fab17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81357f9d197b142b8126579ce51fab17">&#9670;&nbsp;</a></span>swaplr() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Comparator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a05401.html">Tree::binaryTree</a>&lt; T, Comparator &gt;::swaplr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>交换左右子树 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_root</td><td>指向树的根结点的指针 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>不允许用户指定参数 </dd></dl>

<p class="definition">Definition at line <a class="el" href="a04520_source.html#l00404">404</a> of file <a class="el" href="a04520_source.html">binaryTree.hh</a>.</p>

<p class="reference">Referenced by <a class="el" href="a04571_source.html#l00051">main()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="a05401_a81357f9d197b142b8126579ce51fab17_icgraph.svg" width="270" height="38"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="ac72226f157079d3e873a6412a7f6f9a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac72226f157079d3e873a6412a7f6f9a3">&#9670;&nbsp;</a></span>swaplr() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , typename Comparator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a05401.html">Tree::binaryTree</a>&lt; T, Comparator &gt;::swaplr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a05405.html">BinNode</a> *&#160;</td>
          <td class="paramname"><em>_root</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>交换左右子树 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_root</td><td>指向树的根结点的指针 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>类的工具函数 </dd></dl>

<p class="definition">Definition at line <a class="el" href="a04520_source.html#l01071">1071</a> of file <a class="el" href="a04520_source.html">binaryTree.hh</a>.</p>

</div>
</div>
<a id="addaed7635a0453b38ab8eda812a8d5a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addaed7635a0453b38ab8eda812a8d5a0">&#9670;&nbsp;</a></span>value_type_equal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Comparator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool <a class="el" href="a05401.html">Tree::binaryTree</a>&lt; T, Comparator &gt;::value_type_equal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a05401.html#afaa28be8afcfed930217d6d75ae18383">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a05401.html#afaa28be8afcfed930217d6d75ae18383">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>比较value_type类型对象的大小。 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>左运算数 </td></tr>
    <tr><td class="paramname">rhs</td><td>右运算数 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true lhs == rhs </dd>
<dd>
false lhs != rhs </dd></dl>

<p class="definition">Definition at line <a class="el" href="a04520_source.html#l00538">538</a> of file <a class="el" href="a04520_source.html">binaryTree.hh</a>.</p>

</div>
</div>
<a id="acff903bc85aae48ad28856ab8a990bc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acff903bc85aae48ad28856ab8a990bc4">&#9670;&nbsp;</a></span>value_type_less()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Comparator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool <a class="el" href="a05401.html">Tree::binaryTree</a>&lt; T, Comparator &gt;::value_type_less </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a05401.html#afaa28be8afcfed930217d6d75ae18383">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a05401.html#afaa28be8afcfed930217d6d75ae18383">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>比较value_type类型对象的大小。 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>左运算数 </td></tr>
    <tr><td class="paramname">rhs</td><td>右运算数 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true lhs &lt; rhs </dd>
<dd>
false lhs &gt;= rhs </dd></dl>

<p class="definition">Definition at line <a class="el" href="a04520_source.html#l00528">528</a> of file <a class="el" href="a04520_source.html">binaryTree.hh</a>.</p>

</div>
</div>
<a id="a1811f886d68ab66847e6ceebd91570c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1811f886d68ab66847e6ceebd91570c3">&#9670;&nbsp;</a></span>value_type_less_equal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Comparator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool <a class="el" href="a05401.html">Tree::binaryTree</a>&lt; T, Comparator &gt;::value_type_less_equal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a05401.html#afaa28be8afcfed930217d6d75ae18383">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a05401.html#afaa28be8afcfed930217d6d75ae18383">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>比较value_type类型对象的大小。 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>左运算数 </td></tr>
    <tr><td class="paramname">rhs</td><td>右运算数 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true lhs &lt;= rhs </dd>
<dd>
false lhs &gt; rhs </dd></dl>

<p class="definition">Definition at line <a class="el" href="a04520_source.html#l00548">548</a> of file <a class="el" href="a04520_source.html">binaryTree.hh</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="af67a715c8762e222910cecaefadc4b26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af67a715c8762e222910cecaefadc4b26">&#9670;&nbsp;</a></span>operator==</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Comparator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a05401.html">binaryTree</a>&lt; T, Comparator &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a05401.html">binaryTree</a>&lt; T, Comparator &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>比较两棵二叉树是否相同 "相同"是指： </p>
<p>不能在此声明下述友元(invalid use of incomplete type)， 原因：类的内部类型value_type未声明。 只需把友元声明置于typedef后即可</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>数据类型 </td></tr>
    <tr><td class="paramname">Comparator</td><td>数据类型的比较器类，默认为std::less&lt;T&gt; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>此函数模板的模板实参由函数实参表推断，用户无需指定</dd></dl>
<p>若类型T重载了operator&lt;，则Comparator的默认类型std::less&lt;T&gt;将调用operator&lt;，故实例化时不必指定tparam2；<br  />
否则，要求指定模板参数Comparator，which is a function object, 重载了bool operator(T t1, T t2)：当语义上t1 &lt; t2时返回true。 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>二叉树#1 </td></tr>
    <tr><td class="paramname">rhs</td><td>二叉树#2 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true #1和#2相同 </dd>
<dd>
false #1和#2不同 </dd></dl>

<p class="definition">Definition at line <a class="el" href="a04520_source.html#l01462">1462</a> of file <a class="el" href="a04520_source.html">binaryTree.hh</a>.</p>

</div>
</div>
<a id="a93afab389963fd3c1c581ef3ebae3432"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93afab389963fd3c1c581ef3ebae3432">&#9670;&nbsp;</a></span>printBinaryTree</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Comparator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void printBinaryTree </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a05401.html">binaryTree</a>&lt; T, Comparator &gt; &amp;&#160;</td>
          <td class="paramname"><em>bin_tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="a05401.html">binaryTree</a>&lt; T, Comparator &gt; ::<a class="el" href="a05401.html#afaa28be8afcfed930217d6d75ae18383">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>flag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ad6b1eaee9b04cf92b17732ee573786c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6b1eaee9b04cf92b17732ee573786c0">&#9670;&nbsp;</a></span>const_reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Comparator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const typedef <a class="el" href="a05401.html#afaa28be8afcfed930217d6d75ae18383">value_type</a>&amp; <a class="el" href="a05401.html">Tree::binaryTree</a>&lt; T, Comparator &gt;::const_reference</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>数据的常量引用 </p>

<p class="definition">Definition at line <a class="el" href="a04520_source.html#l00110">110</a> of file <a class="el" href="a04520_source.html">binaryTree.hh</a>.</p>

</div>
</div>
<a id="a2d83bc4e269a3a8f81db1f6c79824c9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d83bc4e269a3a8f81db1f6c79824c9e">&#9670;&nbsp;</a></span>is_less_than_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , typename Comparator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Comparator <a class="el" href="a05401.html">Tree::binaryTree</a>&lt; T, Comparator &gt;::is_less_than_ = Comparator{}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>比较器(function object) </p>

<p class="definition">Definition at line <a class="el" href="a04520_source.html#l00518">518</a> of file <a class="el" href="a04520_source.html">binaryTree.hh</a>.</p>

</div>
</div>
<a id="ab518fbeddcd16a35e087ab5ce6bdec16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab518fbeddcd16a35e087ab5ce6bdec16">&#9670;&nbsp;</a></span>root_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Comparator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a05405.html">BinNode</a>* <a class="el" href="a05401.html">Tree::binaryTree</a>&lt; T, Comparator &gt;::root_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>二叉树的根结点 </p>

<p class="definition">Definition at line <a class="el" href="a04520_source.html#l00151">151</a> of file <a class="el" href="a04520_source.html">binaryTree.hh</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/<a class="el" href="a04520_source.html">binaryTree.hh</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="a04583.html">Tree</a></li><li class="navelem"><a class="el" href="a05401.html">binaryTree</a></li>
    <li class="footer">Generated on Sun Jul 5 2020 16:54:24 for 树 by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
